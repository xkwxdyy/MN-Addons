<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>自适应大小的 Mermaid 图表</title>
    <script src="mermaid.js" defer></script>
    <link rel="stylesheet" href="notyf.css">
    <script src="notyf.js" defer></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; 
        }

        #mermaid-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px; 
            box-sizing: border-box;
        }

        #mermaid-container svg {
            /* * SVG 在 viewBox 属性的帮助下，会保持其原始长宽比，
             * 同时缩放到适应这个 100% 的容器尺寸。
             */
            width: 100%;
            height: calc(100% - 40px);
        }
        /* 加载容器样式 */
        .loading-container {
            text-align: center;
        }

        /* 旋转动画 */
        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #ccc; /* 圈的颜色 */
            border-top: 5px solid #3498db; /* 旋转部分的颜色 */
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px auto; /* 居中并与文字拉开距离 */
        }

        /* 定义旋转动画 */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* “loading” 文字样式 */
        .loading-text {
            font-size: 20px;
            color: #555;
        }
    </style>
</head>
<body>

    <div id="mermaid-container">
      <div class="loading-container">
          <div class="spinner"></div>
          <div class="loading-text">loading</div>
      </div>
    </div>

    <script>
      let notyf

/**
 * 根据指定的 scheme、host、path、query 和 fragment 生成一个完整的 URL Scheme 字符串。
 * URL Scheme 完整格式：scheme://host/path?query#fragment
 *
 * @param {string} scheme - URL scheme，例如 'myapp'。必须提供。
 * @param {string|undefined} [host] - host 部分，例如 'user_profile'。
 * @param {string|string[]|undefined} [path] - path 部分，例如 'view/123'。
 * @param {Object<string, string|number|boolean|object>|undefined} [query] - 查询参数对象。
 * @param {string|undefined} [fragment] - fragment 标识符，即 URL 中 # 后面的部分。
 * @returns {string} - 生成的完整 URL 字符串。
 */
function generateUrlScheme(scheme, host, path, query, fragment) {
  // 1. 处理必须的 scheme
  if (!scheme) {
    console.error("Scheme is a required parameter.");
    return '';
  }
  // 2. 构建基础部分：scheme 和 host
  //    即使 host 为空，也会生成 'scheme://'，这对于 'file:///' 这类 scheme 是正确的
  let url = `${scheme}://${host || ''}`;

  // 3. 添加 path
  if (path) {
    if (Array.isArray(path)) {
      let pathStr = path.join('/')
      url += `/${pathStr.replace(/^\/+/, '')}`;
    }else{
      // 确保 host 和 path 之间只有一个斜杠，并处理 path 开头可能存在的斜杠
      url += `/${path.replace(/^\/+/, '')}`;
    }
  }

  // 4. 添加 query 参数
  if (query && Object.keys(query).length > 0) {
    const queryParts = [];
    for (const key in query) {
      // 确保我们只处理对象自身的属性
      if (Object.prototype.hasOwnProperty.call(query, key)) {
        const value = query[key];
        const encodedKey = encodeURIComponent(key);
        // 对值进行编码，如果是对象，则先序列化为 JSON 字符串
        const encodedValue = encodeURIComponent(
          typeof value === "object" && value !== null ? JSON.stringify(value) : value
        );
        queryParts.push(`${encodedKey}=${encodedValue}`);
      }
    }
    if (queryParts.length > 0) {
      url += `?${queryParts.join('&')}`;
    }
  }

  // 5. 添加 fragment
  if (fragment) {
    // Fragment 部分不应该被编码
    url += `#${fragment}`;
  }

  return url;
}

    /**
     *
     * @param {string} scheme - URL scheme, 例如 'myapp'。
     * @param {string} [host] - 可选的路径或操作名。
     * @param {Object<string, string|number|boolean>} [params] - 查询参数对象。
     */
    function postMessageToAddon(scheme, host, path, params,fragment) {
      let url = generateUrlScheme(scheme,host,path, params,fragment)
      window.location.href = url
    }
    async function validateMermaid(content){
      try {
        let res = await mermaid.render('mermaid-graph', content)
        return {valid:true,svg:res.svg}
      } catch (error) {
        // console.log(error);
        

        // notyf.error(error.message)
        return {valid:false,error:error.message}
      }
    }
    function replaceLtInLatexBlocks(markdown) {
        return markdown.replace(/\$\$(.*?)\$\$/gs, (match, latexContent) => {
            return '$$' + latexContent.replace(/</g, '\\lt') + '$$';
        });
    }

        async function renderMermaid(content){
        try {
          const container = document.getElementById('mermaid-container');
          content = replaceLtInLatexBlocks(content)
          // content = content.replace(/</g, "\\lt")
          // container.innerText = content
          let res = await validateMermaid(content)
          if (!res.valid) {
            if(res.error.includes("KaTeX parse error")) {
              notyf.error("Mermaid 图表解析失败，请检查图表语法是否正确:\n\n"+res.error)
            }
            // document.getElementById('mermaid-container').innerHTML = res.error.message
            postMessageToAddon("snipaste", "mermaid",undefined, {action: "endRendering",content:content})
            return
          }
          
          
            container.innerHTML = res.svg;
            const svgElement = container.querySelector('svg');

            if (svgElement) {
                // 移除这些属性，让 CSS 来控制大小
                svgElement.removeAttribute('width');
                svgElement.removeAttribute('height');
                svgElement.removeAttribute('style');
            }
            postMessageToAddon("snipaste", "mermaid",undefined, {action: "endRendering"})
          
        } catch (error) {
          // console.log(error);
        // notyf.error(error.message)
          // const container = document.getElementById('mermaid-container');
          // container.innerText = error.message
          
            postMessageToAddon("snipaste", "mermaid",undefined, {action: "endRendering",content:content})
        }
        }
      function renderMermaidEncoded(contentEncoded) {
        let content = decodeURIComponent(contentEncoded)
        renderMermaid(content)
      }
      // 监听 DOMContentLoaded 事件
      document.addEventListener('DOMContentLoaded', async function () {
        notyf = new Notyf({position: {x: 'center', y: 'top'}, duration: 1000,ripple:false});
        mermaid.initialize({
            startOnLoad: false,
            securityLevel: 'strict'
        });
        
        postMessageToAddon("snipaste", "mermaid",undefined, {action: "endRendering"})

      })
    </script>
</body>
</html>