/**
 * App - Â∫îÁî®‰∏ªÂÖ•Âè£
 * 
 * ÂäüËÉΩËÅåË¥£:
 * - ÂàùÂßãÂåñÂ∫îÁî®
 * - ÁÆ°ÁêÜÁîüÂëΩÂë®Êúü
 * - ÂçèË∞ÉÂêÑÊ®°Âùó
 * - ÂÖ®Â±ÄÈîôËØØÂ§ÑÁêÜ
 * - ÊÄßËÉΩÁõëÊéß
 */

class TaskBoardApp {
    constructor() {
        this.initialized = false;
        this.components = new Map();
        this.cleanupTasks = [];
        
        // ÊÄßËÉΩÁõëÊéß
        this.performanceObserver = null;
        this.metrics = {
            startTime: performance.now(),
            renderCount: 0,
            errorCount: 0
        };
    }

    /**
     * Initializes the application.
     */
    async init() {
        if (this.initialized) {
            console.warn('App already initialized');
            return;
        }
        
        try {
            console.log('üöÄ Initializing Task Board App...');
            
            // ËÆæÁΩÆÂÖ®Â±ÄÈîôËØØÂ§ÑÁêÜ
            this.setupErrorHandling();
            
            // ËÆæÁΩÆÊÄßËÉΩÁõëÊéß
            this.setupPerformanceMonitoring();
            
            // ÂàùÂßãÂåñÁä∂ÊÄÅÁÆ°ÁêÜÂô®
            await this.initializeStateManager();
            
            // ÂàùÂßãÂåñ‰∏ªÈ¢ò
            this.initializeTheme();
            
            // Ê∏≤ÊüìÂ∫îÁî®
            this.render();
            
            // ÁªëÂÆöÂÖ®Â±Ä‰∫ã‰ª∂
            this.bindGlobalEvents();
            
            // Ê†áËÆ∞ÂàùÂßãÂåñÂÆåÊàê
            this.initialized = true;
            
            // ËÆ∞ÂΩïÂêØÂä®Êó∂Èó¥
            const loadTime = performance.now() - this.metrics.startTime;
            console.log(`‚úÖ App initialized in ${loadTime.toFixed(2)}ms`);
            
        } catch (error) {
            console.error('Failed to initialize app:', error);
            this.showErrorScreen(error);
        }
    }

    /**
     * Sets up global error handling.
     */
    setupErrorHandling() {
        // ÊçïËé∑Êú™Â§ÑÁêÜÁöÑÈîôËØØ
        window.addEventListener('error', (event) => {
            console.error('Global error:', event.error);
            this.metrics.errorCount++;
            
            // ÊòæÁ§∫ÈîôËØØÊèêÁ§∫
            this.showErrorNotification({
                message: event.error.message,
                stack: event.error.stack
            });
            
            // ÈòªÊ≠¢ÈªòËÆ§Ë°å‰∏∫
            event.preventDefault();
        });
        
        // ÊçïËé∑Êú™Â§ÑÁêÜÁöÑ Promise ÊãíÁªù
        window.addEventListener('unhandledrejection', (event) => {
            console.error('Unhandled promise rejection:', event.reason);
            this.metrics.errorCount++;
            
            this.showErrorNotification({
                message: 'Unhandled promise rejection',
                details: event.reason
            });
            
            event.preventDefault();
        });
    }

    /**
     * Sets up performance monitoring.
     */
    setupPerformanceMonitoring() {
        if ('PerformanceObserver' in window) {
            // ÁõëÊéßÈïø‰ªªÂä°
            this.performanceObserver = new PerformanceObserver((list) => {
                for (const entry of list.getEntries()) {
                    if (entry.duration > 50) {
                        console.warn(`Long task detected: ${entry.duration.toFixed(2)}ms`);
                    }
                }
            });
            
            try {
                this.performanceObserver.observe({ entryTypes: ['longtask'] });
            } catch (e) {
                // Êüê‰∫õÊµèËßàÂô®ÂèØËÉΩ‰∏çÊîØÊåÅ longtask
                console.log('Long task monitoring not supported');
            }
        }
        
        // ÂÆöÊúüÊä•ÂëäÊÄßËÉΩÊåáÊ†á
        setInterval(() => {
            this.reportPerformanceMetrics();
        }, 30000);
    }

    /**
     * Initializes state manager with saved data.
     */
    async initializeStateManager() {
        // Âä†ËΩΩ‰øùÂ≠òÁöÑÁä∂ÊÄÅ
        const savedState = TaskBoardUtils.storage.local.get('mntask-board-state');
        
        if (savedState) {
            console.log('Loading saved state...');
            
            // ÊÅ¢Â§ç‰ªªÂä°Êï∞ÊçÆ
            if (savedState.tasks) {
                StateManager.setState({
                    tasks: new Map(savedState.tasks)
                });
            }
            
            // ÊÅ¢Â§çËßÜÂõæÁä∂ÊÄÅ
            if (savedState.view) {
                StateManager.setState({ view: savedState.view });
            }
            
            // ÊÅ¢Â§çÁ≠õÈÄâÂô®
            if (savedState.filters) {
                StateManager.setState({ filters: savedState.filters });
            }
        }
        
        // ËÆæÁΩÆËá™Âä®‰øùÂ≠ò
        this.setupAutoSave();
    }

    /**
     * Sets up auto-save functionality.
     */
    setupAutoSave() {
        const saveState = TaskBoardUtils.fn.debounce(() => {
            const state = {
                tasks: Array.from(StateManager.getState('tasks').entries()),
                view: StateManager.getState('view'),
                filters: {
                    ...StateManager.getState('filters'),
                    statuses: Array.from(StateManager.getState('filters.statuses')),
                    types: Array.from(StateManager.getState('filters.types')),
                    priorities: Array.from(StateManager.getState('filters.priorities'))
                }
            };
            
            TaskBoardUtils.storage.local.set('mntask-board-state', state);
            console.log('State auto-saved');
        }, 5000);
        
        // ÁõëÂê¨Áä∂ÊÄÅÂèòÂåñ
        StateManager.subscribe('*', saveState);
        
        // È°µÈù¢Âç∏ËΩΩÊó∂‰øùÂ≠ò
        window.addEventListener('beforeunload', () => {
            saveState.flush();
        });
    }

    /**
     * Initializes theme based on user preference.
     */
    initializeTheme() {
        const savedTheme = localStorage.getItem('mntask-theme') || 'dark';
        document.documentElement.setAttribute('data-theme', savedTheme);
        StateManager.setState({ ui: { theme: savedTheme } });
    }

    /**
     * Renders the main application.
     */
    render() {
        const container = document.getElementById('app');
        if (!container) {
            throw new Error('App container not found');
        }
        
        // ÂàõÂª∫Â∫îÁî®Â∏ÉÂ±Ä
        const layout = h('div', { className: 'app-layout' },
            h('aside', { className: 'sidebar', id: 'sidebar' }),
            h('main', { className: 'main-content', id: 'main-content' }),
            h('div', { className: 'notifications', id: 'notifications' })
        );
        
        renderEngine.render(layout, container);
        
        // Ê∏≤Êüì‰æßËæπÊ†è
        this.renderSidebar();
        
        // Ê∏≤Êüì‰∏ªÂÜÖÂÆπ
        this.renderMainContent();
        
        this.metrics.renderCount++;
    }

    /**
     * Renders sidebar.
     */
    renderSidebar() {
        const sidebar = document.getElementById('sidebar');
        
        const sidebarComponent = h('div', { className: 'sidebar-content' },
            h('div', { className: 'logo' },
                h('img', { src: 'logo.png', alt: 'MNTask' }),
                h('h2', null, 'MNTask')
            ),
            h('nav', { className: 'nav-menu' },
                this.renderNavMenu()
            ),
            h('div', { className: 'sidebar-footer' },
                this.renderUserInfo(),
                this.renderSettings()
            )
        );
        
        renderEngine.render(sidebarComponent, sidebar);
    }

    /**
     * Renders navigation menu.
     */
    renderNavMenu() {
        const menuItems = [
            { id: 'dashboard', icon: 'üìä', label: '‰ª™Ë°®Áõò' },
            { id: 'tasks', icon: 'üìã', label: '‰ªªÂä°ÂàóË°®' },
            { id: 'timeline', icon: 'üìÖ', label: 'Êó∂Èó¥ËΩ¥' },
            { id: 'projects', icon: 'üìÅ', label: 'È°πÁõÆ' },
            { id: 'reports', icon: 'üìà', label: 'Êä•Âëä' }
        ];
        
        return menuItems.map(item =>
            h('a', {
                className: 'nav-item',
                href: `#${item.id}`,
                onClick: (e) => {
                    e.preventDefault();
                    this.navigateTo(item.id);
                }
            },
                h('span', { className: 'nav-icon' }, item.icon),
                h('span', { className: 'nav-label' }, item.label)
            )
        );
    }

    /**
     * Renders main content area.
     */
    renderMainContent() {
        const mainContent = document.getElementById('main-content');
        
        // ÂàõÂª∫‰ªªÂä°ÁúãÊùøÂÆû‰æã
        const taskBoard = new TaskBoard({});
        this.components.set('taskBoard', taskBoard);
        
        // Ê∏≤Êüì‰ªªÂä°ÁúãÊùø
        renderEngine.render(taskBoard.render(), mainContent);
    }

    /**
     * Binds global events.
     */
    bindGlobalEvents() {
        // ÈîÆÁõòÂø´Êç∑ÈîÆ
        document.addEventListener('keydown', this.handleKeyboardShortcuts.bind(this));
        
        // Á™óÂè£Â§ßÂ∞èÊîπÂèò
        window.addEventListener('resize', TaskBoardUtils.fn.debounce(() => {
            this.handleResize();
        }, 250));
        
        // Âú®Á∫ø/Á¶ªÁ∫øÁä∂ÊÄÅ
        window.addEventListener('online', () => this.handleOnlineStatusChange(true));
        window.addEventListener('offline', () => this.handleOnlineStatusChange(false));
        
        // ÂèØËßÅÊÄßÊîπÂèò
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                this.handleAppPause();
            } else {
                this.handleAppResume();
            }
        });
        
        // Ê∏ÖÁêÜ‰ªªÂä°
        this.cleanupTasks.push(() => {
            document.removeEventListener('keydown', this.handleKeyboardShortcuts);
        });
    }

    /**
     * Handles keyboard shortcuts.
     */
    handleKeyboardShortcuts(e) {
        // Cmd/Ctrl + S: ‰øùÂ≠ò
        if ((e.metaKey || e.ctrlKey) && e.key === 's') {
            e.preventDefault();
            this.saveCurrentState();
        }
        
        // Cmd/Ctrl + F: ÊêúÁ¥¢
        if ((e.metaKey || e.ctrlKey) && e.key === 'f') {
            e.preventDefault();
            this.openSearch();
        }
        
        // Cmd/Ctrl + N: Êñ∞Âª∫‰ªªÂä°
        if ((e.metaKey || e.ctrlKey) && e.key === 'n') {
            e.preventDefault();
            this.createNewTask();
        }
        
        // Esc: ÂÖ≥Èó≠Ê®°ÊÄÅÊ°Ü
        if (e.key === 'Escape') {
            this.closeAllModals();
        }
    }

    /**
     * Navigation handler.
     */
    navigateTo(route) {
        console.log(`Navigating to: ${route}`);
        
        // Êõ¥Êñ∞URL
        window.location.hash = route;
        
        // Êõ¥Êñ∞ËßÜÂõæ
        switch (route) {
            case 'dashboard':
                this.showDashboard();
                break;
            case 'tasks':
                this.showTasks();
                break;
            case 'timeline':
                this.showTimeline();
                break;
            case 'projects':
                this.showProjects();
                break;
            case 'reports':
                this.showReports();
                break;
            default:
                this.show404();
        }
    }

    /**
     * Shows error screen.
     */
    showErrorScreen(error) {
        const container = document.getElementById('app');
        
        const errorScreen = h('div', { className: 'error-screen' },
            h('div', { className: 'error-content' },
                h('h1', null, 'üòµ Âá∫Èîô‰∫Ü'),
                h('p', null, error.message),
                h('pre', null, error.stack),
                h('button', {
                    onClick: () => window.location.reload()
                }, 'ÈáçÊñ∞Âä†ËΩΩ')
            )
        );
        
        renderEngine.render(errorScreen, container);
    }

    /**
     * Shows error notification.
     */
    showErrorNotification(error) {
        const notifications = document.getElementById('notifications');
        
        const notification = TaskBoardUtils.dom.createElement('div', {
            className: 'notification error'
        }, [
            TaskBoardUtils.dom.createElement('div', { className: 'notification-header' }, [
                '‚ùå ÈîôËØØ'
            ]),
            TaskBoardUtils.dom.createElement('div', { className: 'notification-body' }, [
                error.message
            ]),
            TaskBoardUtils.dom.createElement('button', {
                className: 'notification-close',
                onClick: (e) => e.target.parentElement.remove()
            }, ['√ó'])
        ]);
        
        notifications.appendChild(notification);
        
        // Ëá™Âä®ÁßªÈô§
        setTimeout(() => {
            notification.classList.add('fade-out');
            setTimeout(() => notification.remove(), 300);
        }, 5000);
    }

    /**
     * Reports performance metrics.
     */
    reportPerformanceMetrics() {
        const metrics = {
            ...this.metrics,
            memory: performance.memory ? {
                used: Math.round(performance.memory.usedJSHeapSize / 1048576),
                total: Math.round(performance.memory.totalJSHeapSize / 1048576),
                limit: Math.round(performance.memory.jsHeapSizeLimit / 1048576)
            } : null,
            renderStats: window.RenderStats?.getStats(),
            stateSize: StateManager.getAllTasks().length,
            uptime: Math.round((performance.now() - this.metrics.startTime) / 1000)
        };
        
        console.log('üìä Performance Metrics:', metrics);
        
        // Ê£ÄÊü•ÂÜÖÂ≠ò‰ΩøÁî®
        if (metrics.memory && metrics.memory.used > metrics.memory.total * 0.9) {
            console.warn('‚ö†Ô∏è High memory usage detected');
            this.performCleanup();
        }
    }

    /**
     * Performs cleanup to free memory.
     */
    performCleanup() {
        // Ê∏ÖÁêÜÊ∏≤ÊüìÂºïÊìéÁºìÂ≠ò
        window.RenderStats?.clearRecyclePool();
        
        // Ê∏ÖÁêÜ DOM Êü•ËØ¢ÁºìÂ≠ò
        TaskBoardUtils.dom.query.cache?.clear();
        
        // Ëß¶ÂèëÂûÉÂúæÂõûÊî∂ÔºàÂ¶ÇÊûúÂèØÁî®Ôºâ
        if (window.gc) {
            window.gc();
        }
        
        console.log('‚úÖ Cleanup completed');
    }

    /**
     * Handles app pause.
     */
    handleAppPause() {
        console.log('App paused (tab hidden)');
        
        // ÊöÇÂÅúÈùûÂÖ≥ÈîÆÊõ¥Êñ∞
        StateManager.setState({
            performance: { isUpdating: true }
        });
        
        // ‰øùÂ≠òÂΩìÂâçÁä∂ÊÄÅ
        this.saveCurrentState();
    }

    /**
     * Handles app resume.
     */
    handleAppResume() {
        console.log('App resumed (tab visible)');
        
        // ÊÅ¢Â§çÊõ¥Êñ∞
        StateManager.setState({
            performance: { isUpdating: false }
        });
        
        // Ê£ÄÊü•Êï∞ÊçÆÊõ¥Êñ∞
        this.checkForUpdates();
    }

    /**
     * Handles online status change.
     */
    handleOnlineStatusChange(isOnline) {
        console.log(`Network status: ${isOnline ? 'online' : 'offline'}`);
        
        const notification = {
            message: isOnline ? 'Â∑≤ËøûÊé•Âà∞ÁΩëÁªú' : 'ÁΩëÁªúËøûÊé•Â∑≤Êñ≠ÂºÄ',
            type: isOnline ? 'success' : 'warning'
        };
        
        this.showNotification(notification);
    }

    /**
     * Shows notification.
     */
    showNotification({ message, type = 'info' }) {
        const notifications = document.getElementById('notifications');
        
        const notification = TaskBoardUtils.dom.createElement('div', {
            className: `notification ${type}`
        }, [message]);
        
        notifications.appendChild(notification);
        
        setTimeout(() => {
            notification.classList.add('fade-out');
            setTimeout(() => notification.remove(), 300);
        }, 3000);
    }

    /**
     * Saves current state.
     */
    saveCurrentState() {
        const state = {
            tasks: Array.from(StateManager.getState('tasks').entries()),
            view: StateManager.getState('view'),
            filters: StateManager.getState('filters'),
            timestamp: Date.now()
        };
        
        TaskBoardUtils.storage.local.set('mntask-board-state', state);
        this.showNotification({ message: 'Â∑≤‰øùÂ≠ò', type: 'success' });
    }

    /**
     * Destroys the application.
     */
    destroy() {
        console.log('Destroying app...');
        
        // ÊâßË°åÊ∏ÖÁêÜ‰ªªÂä°
        this.cleanupTasks.forEach(task => task());
        
        // ÈîÄÊØÅÁªÑ‰ª∂
        this.components.forEach(component => {
            if (component.destroy) {
                component.destroy();
            }
        });
        
        // ÂÅúÊ≠¢ÊÄßËÉΩÁõëÊéß
        if (this.performanceObserver) {
            this.performanceObserver.disconnect();
        }
        
        // Ê∏ÖÁêÜÂÖ®Â±ÄÂØπË±°
        window.dragManager?.destroy();
        
        // ÈáçÁΩÆÁä∂ÊÄÅ
        this.initialized = false;
        
        console.log('App destroyed');
    }
}

// ÂàõÂª∫Â∫îÁî®ÂÆû‰æã
const app = new TaskBoardApp();

// È°µÈù¢Âä†ËΩΩÂÆåÊàêÂêéÂàùÂßãÂåñ
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => app.init());
} else {
    app.init();
}

// ÂØºÂá∫Â∫îÁî®ÂÆû‰æã
window.taskBoardApp = app;